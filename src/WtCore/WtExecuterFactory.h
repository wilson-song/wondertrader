#pragma once
#include "IExecCommand.h"
#include "../Includes/ExecuteDefs.h"
#include "../Share/DLLHelper.hpp"

#include <boost/core/noncopyable.hpp>

NS_WTP_BEGIN

//////////////////////////////////////////////////////////////////////////
//执行单元封装
//因为执行单元是dll里创建的, 如果不封装的话, 直接delete可能会有问题
//所以要把工厂指针一起封装到这里, 直接调用工厂实例的deleteUnit方法释放执行单元
class ExeUnitWrapper
{
public:
	ExeUnitWrapper(ExecuteUnit* unitPtr, IExecuterFactory* fact) : _unit(unitPtr), _fact(fact) {}
	~ExeUnitWrapper()
	{
		if (_unit)
		{
			_fact->deleteExeUnit(_unit);
		}
	}

	ExecuteUnit* self() { return _unit; }


private:
	ExecuteUnit*	_unit;
	IExecuterFactory*	_fact;
};

typedef std::shared_ptr<ExeUnitWrapper>	ExecuteUnitPtr;
typedef faster_hashmap<LongKey, ExecuteUnitPtr> ExecuteUnitMap;

//////////////////////////////////////////////////////////////////////////
//执行器工厂类
class WtExecuterFactory : private boost::noncopyable
{
public:
	~WtExecuterFactory() = default;

public:
	bool loadFactories(const char* path);

	ExecuteUnitPtr createExeUnit(const char* name);
	ExecuteUnitPtr createDiffExeUnit(const char* name);

	ExecuteUnitPtr createExeUnit(const char* factname, const char* unitname);
	ExecuteUnitPtr createDiffExeUnit(const char* factname, const char* unitname);

private:
	typedef struct ExeFactInfo
	{
		std::string		_module_path;
		DllHandle		_module_inst;
		IExecuterFactory*	_fact;
		FuncCreateExeFactory	_creator;
		FuncDeleteExeFactory	_remover;
	} ExeFactInfo;
	typedef faster_hashmap<LongKey, ExeFactInfo> ExeFactMap;

	ExeFactMap	_factories;
};


NS_WTP_END
